<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>bower_components/webcomponentsjs/webcomponents-lite.js - {{project_name}}</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="http://ato.ms/images/atomslogo.png" title="{{project_name}}"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.0.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/getInitialValue.html">getInitialValue</a></li>
                                <li><a href="../classes/{{element_name}}.html">{{element_name}}</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: bower_components/webcomponentsjs/webcomponents-lite.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 * @license
 * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */
// @version 0.7.12
window.WebComponents = window.WebComponents || {};

(function(scope) {
  var flags = scope.flags || {};
  var file = &quot;webcomponents-lite.js&quot;;
  var script = document.querySelector(&#x27;script[src*=&quot;&#x27; + file + &#x27;&quot;]&#x27;);
  if (!flags.noOpts) {
    location.search.slice(1).split(&quot;&amp;&quot;).forEach(function(option) {
      var parts = option.split(&quot;=&quot;);
      var match;
      if (parts[0] &amp;&amp; (match = parts[0].match(/wc-(.+)/))) {
        flags[match[1]] = parts[1] || true;
      }
    });
    if (script) {
      for (var i = 0, a; a = script.attributes[i]; i++) {
        if (a.name !== &quot;src&quot;) {
          flags[a.name] = a.value || true;
        }
      }
    }
    if (flags.log) {
      var parts = flags.log.split(&quot;,&quot;);
      flags.log = {};
      parts.forEach(function(f) {
        flags.log[f] = true;
      });
    } else {
      flags.log = {};
    }
  }
  flags.shadow = flags.shadow || flags.shadowdom || flags.polyfill;
  if (flags.shadow === &quot;native&quot;) {
    flags.shadow = false;
  } else {
    flags.shadow = flags.shadow || !HTMLElement.prototype.createShadowRoot;
  }
  if (flags.register) {
    window.CustomElements = window.CustomElements || {
      flags: {}
    };
    window.CustomElements.flags.register = flags.register;
  }
  scope.flags = flags;
})(window.WebComponents);

(function(scope) {
  &quot;use strict&quot;;
  var hasWorkingUrl = false;
  if (!scope.forceJURL) {
    try {
      var u = new URL(&quot;b&quot;, &quot;http://a&quot;);
      u.pathname = &quot;c%20d&quot;;
      hasWorkingUrl = u.href === &quot;http://a/c%20d&quot;;
    } catch (e) {}
  }
  if (hasWorkingUrl) return;
  var relative = Object.create(null);
  relative[&quot;ftp&quot;] = 21;
  relative[&quot;file&quot;] = 0;
  relative[&quot;gopher&quot;] = 70;
  relative[&quot;http&quot;] = 80;
  relative[&quot;https&quot;] = 443;
  relative[&quot;ws&quot;] = 80;
  relative[&quot;wss&quot;] = 443;
  var relativePathDotMapping = Object.create(null);
  relativePathDotMapping[&quot;%2e&quot;] = &quot;.&quot;;
  relativePathDotMapping[&quot;.%2e&quot;] = &quot;..&quot;;
  relativePathDotMapping[&quot;%2e.&quot;] = &quot;..&quot;;
  relativePathDotMapping[&quot;%2e%2e&quot;] = &quot;..&quot;;
  function isRelativeScheme(scheme) {
    return relative[scheme] !== undefined;
  }
  function invalid() {
    clear.call(this);
    this._isInvalid = true;
  }
  function IDNAToASCII(h) {
    if (&quot;&quot; == h) {
      invalid.call(this);
    }
    return h.toLowerCase();
  }
  function percentEscape(c) {
    var unicode = c.charCodeAt(0);
    if (unicode &gt; 32 &amp;&amp; unicode &lt; 127 &amp;&amp; [ 34, 35, 60, 62, 63, 96 ].indexOf(unicode) == -1) {
      return c;
    }
    return encodeURIComponent(c);
  }
  function percentEscapeQuery(c) {
    var unicode = c.charCodeAt(0);
    if (unicode &gt; 32 &amp;&amp; unicode &lt; 127 &amp;&amp; [ 34, 35, 60, 62, 96 ].indexOf(unicode) == -1) {
      return c;
    }
    return encodeURIComponent(c);
  }
  var EOF = undefined, ALPHA = /[a-zA-Z]/, ALPHANUMERIC = /[a-zA-Z0-9\+\-\.]/;
  function parse(input, stateOverride, base) {
    function err(message) {
      errors.push(message);
    }
    var state = stateOverride || &quot;scheme start&quot;, cursor = 0, buffer = &quot;&quot;, seenAt = false, seenBracket = false, errors = [];
    loop: while ((input[cursor - 1] != EOF || cursor == 0) &amp;&amp; !this._isInvalid) {
      var c = input[cursor];
      switch (state) {
       case &quot;scheme start&quot;:
        if (c &amp;&amp; ALPHA.test(c)) {
          buffer += c.toLowerCase();
          state = &quot;scheme&quot;;
        } else if (!stateOverride) {
          buffer = &quot;&quot;;
          state = &quot;no scheme&quot;;
          continue;
        } else {
          err(&quot;Invalid scheme.&quot;);
          break loop;
        }
        break;

       case &quot;scheme&quot;:
        if (c &amp;&amp; ALPHANUMERIC.test(c)) {
          buffer += c.toLowerCase();
        } else if (&quot;:&quot; == c) {
          this._scheme = buffer;
          buffer = &quot;&quot;;
          if (stateOverride) {
            break loop;
          }
          if (isRelativeScheme(this._scheme)) {
            this._isRelative = true;
          }
          if (&quot;file&quot; == this._scheme) {
            state = &quot;relative&quot;;
          } else if (this._isRelative &amp;&amp; base &amp;&amp; base._scheme == this._scheme) {
            state = &quot;relative or authority&quot;;
          } else if (this._isRelative) {
            state = &quot;authority first slash&quot;;
          } else {
            state = &quot;scheme data&quot;;
          }
        } else if (!stateOverride) {
          buffer = &quot;&quot;;
          cursor = 0;
          state = &quot;no scheme&quot;;
          continue;
        } else if (EOF == c) {
          break loop;
        } else {
          err(&quot;Code point not allowed in scheme: &quot; + c);
          break loop;
        }
        break;

       case &quot;scheme data&quot;:
        if (&quot;?&quot; == c) {
          this._query = &quot;?&quot;;
          state = &quot;query&quot;;
        } else if (&quot;#&quot; == c) {
          this._fragment = &quot;#&quot;;
          state = &quot;fragment&quot;;
        } else {
          if (EOF != c &amp;&amp; &quot;	&quot; != c &amp;&amp; &quot;\n&quot; != c &amp;&amp; &quot;\r&quot; != c) {
            this._schemeData += percentEscape(c);
          }
        }
        break;

       case &quot;no scheme&quot;:
        if (!base || !isRelativeScheme(base._scheme)) {
          err(&quot;Missing scheme.&quot;);
          invalid.call(this);
        } else {
          state = &quot;relative&quot;;
          continue;
        }
        break;

       case &quot;relative or authority&quot;:
        if (&quot;/&quot; == c &amp;&amp; &quot;/&quot; == input[cursor + 1]) {
          state = &quot;authority ignore slashes&quot;;
        } else {
          err(&quot;Expected /, got: &quot; + c);
          state = &quot;relative&quot;;
          continue;
        }
        break;

       case &quot;relative&quot;:
        this._isRelative = true;
        if (&quot;file&quot; != this._scheme) this._scheme = base._scheme;
        if (EOF == c) {
          this._host = base._host;
          this._port = base._port;
          this._path = base._path.slice();
          this._query = base._query;
          this._username = base._username;
          this._password = base._password;
          break loop;
        } else if (&quot;/&quot; == c || &quot;\\&quot; == c) {
          if (&quot;\\&quot; == c) err(&quot;\\ is an invalid code point.&quot;);
          state = &quot;relative slash&quot;;
        } else if (&quot;?&quot; == c) {
          this._host = base._host;
          this._port = base._port;
          this._path = base._path.slice();
          this._query = &quot;?&quot;;
          this._username = base._username;
          this._password = base._password;
          state = &quot;query&quot;;
        } else if (&quot;#&quot; == c) {
          this._host = base._host;
          this._port = base._port;
          this._path = base._path.slice();
          this._query = base._query;
          this._fragment = &quot;#&quot;;
          this._username = base._username;
          this._password = base._password;
          state = &quot;fragment&quot;;
        } else {
          var nextC = input[cursor + 1];
          var nextNextC = input[cursor + 2];
          if (&quot;file&quot; != this._scheme || !ALPHA.test(c) || nextC != &quot;:&quot; &amp;&amp; nextC != &quot;|&quot; || EOF != nextNextC &amp;&amp; &quot;/&quot; != nextNextC &amp;&amp; &quot;\\&quot; != nextNextC &amp;&amp; &quot;?&quot; != nextNextC &amp;&amp; &quot;#&quot; != nextNextC) {
            this._host = base._host;
            this._port = base._port;
            this._username = base._username;
            this._password = base._password;
            this._path = base._path.slice();
            this._path.pop();
          }
          state = &quot;relative path&quot;;
          continue;
        }
        break;

       case &quot;relative slash&quot;:
        if (&quot;/&quot; == c || &quot;\\&quot; == c) {
          if (&quot;\\&quot; == c) {
            err(&quot;\\ is an invalid code point.&quot;);
          }
          if (&quot;file&quot; == this._scheme) {
            state = &quot;file host&quot;;
          } else {
            state = &quot;authority ignore slashes&quot;;
          }
        } else {
          if (&quot;file&quot; != this._scheme) {
            this._host = base._host;
            this._port = base._port;
            this._username = base._username;
            this._password = base._password;
          }
          state = &quot;relative path&quot;;
          continue;
        }
        break;

       case &quot;authority first slash&quot;:
        if (&quot;/&quot; == c) {
          state = &quot;authority second slash&quot;;
        } else {
          err(&quot;Expected &#x27;/&#x27;, got: &quot; + c);
          state = &quot;authority ignore slashes&quot;;
          continue;
        }
        break;

       case &quot;authority second slash&quot;:
        state = &quot;authority ignore slashes&quot;;
        if (&quot;/&quot; != c) {
          err(&quot;Expected &#x27;/&#x27;, got: &quot; + c);
          continue;
        }
        break;

       case &quot;authority ignore slashes&quot;:
        if (&quot;/&quot; != c &amp;&amp; &quot;\\&quot; != c) {
          state = &quot;authority&quot;;
          continue;
        } else {
          err(&quot;Expected authority, got: &quot; + c);
        }
        break;

       case &quot;authority&quot;:
        if (&quot;@&quot; == c) {
          if (seenAt) {
            err(&quot;@ already seen.&quot;);
            buffer += &quot;%40&quot;;
          }
          seenAt = true;
          for (var i = 0; i &lt; buffer.length; i++) {
            var cp = buffer[i];
            if (&quot;	&quot; == cp || &quot;\n&quot; == cp || &quot;\r&quot; == cp) {
              err(&quot;Invalid whitespace in authority.&quot;);
              continue;
            }
            if (&quot;:&quot; == cp &amp;&amp; null === this._password) {
              this._password = &quot;&quot;;
              continue;
            }
            var tempC = percentEscape(cp);
            null !== this._password ? this._password += tempC : this._username += tempC;
          }
          buffer = &quot;&quot;;
        } else if (EOF == c || &quot;/&quot; == c || &quot;\\&quot; == c || &quot;?&quot; == c || &quot;#&quot; == c) {
          cursor -= buffer.length;
          buffer = &quot;&quot;;
          state = &quot;host&quot;;
          continue;
        } else {
          buffer += c;
        }
        break;

       case &quot;file host&quot;:
        if (EOF == c || &quot;/&quot; == c || &quot;\\&quot; == c || &quot;?&quot; == c || &quot;#&quot; == c) {
          if (buffer.length == 2 &amp;&amp; ALPHA.test(buffer[0]) &amp;&amp; (buffer[1] == &quot;:&quot; || buffer[1] == &quot;|&quot;)) {
            state = &quot;relative path&quot;;
          } else if (buffer.length == 0) {
            state = &quot;relative path start&quot;;
          } else {
            this._host = IDNAToASCII.call(this, buffer);
            buffer = &quot;&quot;;
            state = &quot;relative path start&quot;;
          }
          continue;
        } else if (&quot;	&quot; == c || &quot;\n&quot; == c || &quot;\r&quot; == c) {
          err(&quot;Invalid whitespace in file host.&quot;);
        } else {
          buffer += c;
        }
        break;

       case &quot;host&quot;:
       case &quot;hostname&quot;:
        if (&quot;:&quot; == c &amp;&amp; !seenBracket) {
          this._host = IDNAToASCII.call(this, buffer);
          buffer = &quot;&quot;;
          state = &quot;port&quot;;
          if (&quot;hostname&quot; == stateOverride) {
            break loop;
          }
        } else if (EOF == c || &quot;/&quot; == c || &quot;\\&quot; == c || &quot;?&quot; == c || &quot;#&quot; == c) {
          this._host = IDNAToASCII.call(this, buffer);
          buffer = &quot;&quot;;
          state = &quot;relative path start&quot;;
          if (stateOverride) {
            break loop;
          }
          continue;
        } else if (&quot;	&quot; != c &amp;&amp; &quot;\n&quot; != c &amp;&amp; &quot;\r&quot; != c) {
          if (&quot;[&quot; == c) {
            seenBracket = true;
          } else if (&quot;]&quot; == c) {
            seenBracket = false;
          }
          buffer += c;
        } else {
          err(&quot;Invalid code point in host/hostname: &quot; + c);
        }
        break;

       case &quot;port&quot;:
        if (/[0-9]/.test(c)) {
          buffer += c;
        } else if (EOF == c || &quot;/&quot; == c || &quot;\\&quot; == c || &quot;?&quot; == c || &quot;#&quot; == c || stateOverride) {
          if (&quot;&quot; != buffer) {
            var temp = parseInt(buffer, 10);
            if (temp != relative[this._scheme]) {
              this._port = temp + &quot;&quot;;
            }
            buffer = &quot;&quot;;
          }
          if (stateOverride) {
            break loop;
          }
          state = &quot;relative path start&quot;;
          continue;
        } else if (&quot;	&quot; == c || &quot;\n&quot; == c || &quot;\r&quot; == c) {
          err(&quot;Invalid code point in port: &quot; + c);
        } else {
          invalid.call(this);
        }
        break;

       case &quot;relative path start&quot;:
        if (&quot;\\&quot; == c) err(&quot;&#x27;\\&#x27; not allowed in path.&quot;);
        state = &quot;relative path&quot;;
        if (&quot;/&quot; != c &amp;&amp; &quot;\\&quot; != c) {
          continue;
        }
        break;

       case &quot;relative path&quot;:
        if (EOF == c || &quot;/&quot; == c || &quot;\\&quot; == c || !stateOverride &amp;&amp; (&quot;?&quot; == c || &quot;#&quot; == c)) {
          if (&quot;\\&quot; == c) {
            err(&quot;\\ not allowed in relative path.&quot;);
          }
          var tmp;
          if (tmp = relativePathDotMapping[buffer.toLowerCase()]) {
            buffer = tmp;
          }
          if (&quot;..&quot; == buffer) {
            this._path.pop();
            if (&quot;/&quot; != c &amp;&amp; &quot;\\&quot; != c) {
              this._path.push(&quot;&quot;);
            }
          } else if (&quot;.&quot; == buffer &amp;&amp; &quot;/&quot; != c &amp;&amp; &quot;\\&quot; != c) {
            this._path.push(&quot;&quot;);
          } else if (&quot;.&quot; != buffer) {
            if (&quot;file&quot; == this._scheme &amp;&amp; this._path.length == 0 &amp;&amp; buffer.length == 2 &amp;&amp; ALPHA.test(buffer[0]) &amp;&amp; buffer[1] == &quot;|&quot;) {
              buffer = buffer[0] + &quot;:&quot;;
            }
            this._path.push(buffer);
          }
          buffer = &quot;&quot;;
          if (&quot;?&quot; == c) {
            this._query = &quot;?&quot;;
            state = &quot;query&quot;;
          } else if (&quot;#&quot; == c) {
            this._fragment = &quot;#&quot;;
            state = &quot;fragment&quot;;
          }
        } else if (&quot;	&quot; != c &amp;&amp; &quot;\n&quot; != c &amp;&amp; &quot;\r&quot; != c) {
          buffer += percentEscape(c);
        }
        break;

       case &quot;query&quot;:
        if (!stateOverride &amp;&amp; &quot;#&quot; == c) {
          this._fragment = &quot;#&quot;;
          state = &quot;fragment&quot;;
        } else if (EOF != c &amp;&amp; &quot;	&quot; != c &amp;&amp; &quot;\n&quot; != c &amp;&amp; &quot;\r&quot; != c) {
          this._query += percentEscapeQuery(c);
        }
        break;

       case &quot;fragment&quot;:
        if (EOF != c &amp;&amp; &quot;	&quot; != c &amp;&amp; &quot;\n&quot; != c &amp;&amp; &quot;\r&quot; != c) {
          this._fragment += c;
        }
        break;
      }
      cursor++;
    }
  }
  function clear() {
    this._scheme = &quot;&quot;;
    this._schemeData = &quot;&quot;;
    this._username = &quot;&quot;;
    this._password = null;
    this._host = &quot;&quot;;
    this._port = &quot;&quot;;
    this._path = [];
    this._query = &quot;&quot;;
    this._fragment = &quot;&quot;;
    this._isInvalid = false;
    this._isRelative = false;
  }
  function jURL(url, base) {
    if (base !== undefined &amp;&amp; !(base instanceof jURL)) base = new jURL(String(base));
    this._url = url;
    clear.call(this);
    var input = url.replace(/^[ \t\r\n\f]+|[ \t\r\n\f]+$/g, &quot;&quot;);
    parse.call(this, input, null, base);
  }
  jURL.prototype = {
    toString: function() {
      return this.href;
    },
    get href() {
      if (this._isInvalid) return this._url;
      var authority = &quot;&quot;;
      if (&quot;&quot; != this._username || null != this._password) {
        authority = this._username + (null != this._password ? &quot;:&quot; + this._password : &quot;&quot;) + &quot;@&quot;;
      }
      return this.protocol + (this._isRelative ? &quot;//&quot; + authority + this.host : &quot;&quot;) + this.pathname + this._query + this._fragment;
    },
    set href(href) {
      clear.call(this);
      parse.call(this, href);
    },
    get protocol() {
      return this._scheme + &quot;:&quot;;
    },
    set protocol(protocol) {
      if (this._isInvalid) return;
      parse.call(this, protocol + &quot;:&quot;, &quot;scheme start&quot;);
    },
    get host() {
      return this._isInvalid ? &quot;&quot; : this._port ? this._host + &quot;:&quot; + this._port : this._host;
    },
    set host(host) {
      if (this._isInvalid || !this._isRelative) return;
      parse.call(this, host, &quot;host&quot;);
    },
    get hostname() {
      return this._host;
    },
    set hostname(hostname) {
      if (this._isInvalid || !this._isRelative) return;
      parse.call(this, hostname, &quot;hostname&quot;);
    },
    get port() {
      return this._port;
    },
    set port(port) {
      if (this._isInvalid || !this._isRelative) return;
      parse.call(this, port, &quot;port&quot;);
    },
    get pathname() {
      return this._isInvalid ? &quot;&quot; : this._isRelative ? &quot;/&quot; + this._path.join(&quot;/&quot;) : this._schemeData;
    },
    set pathname(pathname) {
      if (this._isInvalid || !this._isRelative) return;
      this._path = [];
      parse.call(this, pathname, &quot;relative path start&quot;);
    },
    get search() {
      return this._isInvalid || !this._query || &quot;?&quot; == this._query ? &quot;&quot; : this._query;
    },
    set search(search) {
      if (this._isInvalid || !this._isRelative) return;
      this._query = &quot;?&quot;;
      if (&quot;?&quot; == search[0]) search = search.slice(1);
      parse.call(this, search, &quot;query&quot;);
    },
    get hash() {
      return this._isInvalid || !this._fragment || &quot;#&quot; == this._fragment ? &quot;&quot; : this._fragment;
    },
    set hash(hash) {
      if (this._isInvalid) return;
      this._fragment = &quot;#&quot;;
      if (&quot;#&quot; == hash[0]) hash = hash.slice(1);
      parse.call(this, hash, &quot;fragment&quot;);
    },
    get origin() {
      var host;
      if (this._isInvalid || !this._scheme) {
        return &quot;&quot;;
      }
      switch (this._scheme) {
       case &quot;data&quot;:
       case &quot;file&quot;:
       case &quot;javascript&quot;:
       case &quot;mailto&quot;:
        return &quot;null&quot;;
      }
      host = this.host;
      if (!host) {
        return &quot;&quot;;
      }
      return this._scheme + &quot;://&quot; + host;
    }
  };
  var OriginalURL = scope.URL;
  if (OriginalURL) {
    jURL.createObjectURL = function(blob) {
      return OriginalURL.createObjectURL.apply(OriginalURL, arguments);
    };
    jURL.revokeObjectURL = function(url) {
      OriginalURL.revokeObjectURL(url);
    };
  }
  scope.URL = jURL;
})(this);

if (typeof WeakMap === &quot;undefined&quot;) {
  (function() {
    var defineProperty = Object.defineProperty;
    var counter = Date.now() % 1e9;
    var WeakMap = function() {
      this.name = &quot;__st&quot; + (Math.random() * 1e9 &gt;&gt;&gt; 0) + (counter++ + &quot;__&quot;);
    };
    WeakMap.prototype = {
      set: function(key, value) {
        var entry = key[this.name];
        if (entry &amp;&amp; entry[0] === key) entry[1] = value; else defineProperty(key, this.name, {
          value: [ key, value ],
          writable: true
        });
        return this;
      },
      get: function(key) {
        var entry;
        return (entry = key[this.name]) &amp;&amp; entry[0] === key ? entry[1] : undefined;
      },
      &quot;delete&quot;: function(key) {
        var entry = key[this.name];
        if (!entry || entry[0] !== key) return false;
        entry[0] = entry[1] = undefined;
        return true;
      },
      has: function(key) {
        var entry = key[this.name];
        if (!entry) return false;
        return entry[0] === key;
      }
    };
    window.WeakMap = WeakMap;
  })();
}

(function(global) {
  var registrationsTable = new WeakMap();
  var setImmediate;
  if (/Trident|Edge/.test(navigator.userAgent)) {
    setImmediate = setTimeout;
  } else if (window.setImmediate) {
    setImmediate = window.setImmediate;
  } else {
    var setImmediateQueue = [];
    var sentinel = String(Math.random());
    window.addEventListener(&quot;message&quot;, function(e) {
      if (e.data === sentinel) {
        var queue = setImmediateQueue;
        setImmediateQueue = [];
        queue.forEach(function(func) {
          func();
        });
      }
    });
    setImmediate = function(func) {
      setImmediateQueue.push(func);
      window.postMessage(sentinel, &quot;*&quot;);
    };
  }
  var isScheduled = false;
  var scheduledObservers = [];
  function scheduleCallback(observer) {
    scheduledObservers.push(observer);
    if (!isScheduled) {
      isScheduled = true;
      setImmediate(dispatchCallbacks);
    }
  }
  function wrapIfNeeded(node) {
    return window.ShadowDOMPolyfill &amp;&amp; window.ShadowDOMPolyfill.wrapIfNeeded(node) || node;
  }
  function dispatchCallbacks() {
    isScheduled = false;
    var observers = scheduledObservers;
    scheduledObservers = [];
    observers.sort(function(o1, o2) {
      return o1.uid_ - o2.uid_;
    });
    var anyNonEmpty = false;
    observers.forEach(function(observer) {
      var queue = observer.takeRecords();
      removeTransientObserversFor(observer);
      if (queue.length) {
        observer.callback_(queue, observer);
        anyNonEmpty = true;
      }
    });
    if (anyNonEmpty) dispatchCallbacks();
  }
  function removeTransientObserversFor(observer) {
    observer.nodes_.forEach(function(node) {
      var registrations = registrationsTable.get(node);
      if (!registrations) return;
      registrations.forEach(function(registration) {
        if (registration.observer === observer) registration.removeTransientObservers();
      });
    });
  }
  function forEachAncestorAndObserverEnqueueRecord(target, callback) {
    for (var node = target; node; node = node.parentNode) {
      var registrations = registrationsTable.get(node);
      if (registrations) {
        for (var j = 0; j &lt; registrations.length; j++) {
          var registration = registrations[j];
          var options = registration.options;
          if (node !== target &amp;&amp; !options.subtree) continue;
          var record = callback(options);
          if (record) registration.enqueue(record);
        }
      }
    }
  }
  var uidCounter = 0;
  function JsMutationObserver(callback) {
    this.callback_ = callback;
    this.nodes_ = [];
    this.records_ = [];
    this.uid_ = ++uidCounter;
  }
  JsMutationObserver.prototype = {
    observe: function(target, options) {
      target = wrapIfNeeded(target);
      if (!options.childList &amp;&amp; !options.attributes &amp;&amp; !options.characterData || options.attributeOldValue &amp;&amp; !options.attributes || options.attributeFilter &amp;&amp; options.attributeFilter.length &amp;&amp; !options.attributes || options.characterDataOldValue &amp;&amp; !options.characterData) {
        throw new SyntaxError();
      }
      var registrations = registrationsTable.get(target);
      if (!registrations) registrationsTable.set(target, registrations = []);
      var registration;
      for (var i = 0; i &lt; registrations.length; i++) {
        if (registrations[i].observer === this) {
          registration = registrations[i];
          registration.removeListeners();
          registration.options = options;
          break;
        }
      }
      if (!registration) {
        registration = new Registration(this, target, options);
        registrations.push(registration);
        this.nodes_.push(target);
      }
      registration.addListeners();
    },
    disconnect: function() {
      this.nodes_.forEach(function(node) {
        var registrations = registrationsTable.get(node);
        for (var i = 0; i &lt; registrations.length; i++) {
          var registration = registrations[i];
          if (registration.observer === this) {
            registration.removeListeners();
            registrations.splice(i, 1);
            break;
          }
        }
      }, this);
      this.records_ = [];
    },
    takeRecords: function() {
      var copyOfRecords = this.records_;
      this.records_ = [];
      return copyOfRecords;
    }
  };
  function MutationRecord(type, target) {
    this.type = type;
    this.target = target;
    this.addedNodes = [];
    this.removedNodes = [];
    this.previousSibling = null;
    this.nextSibling = null;
    this.attributeName = null;
    this.attributeNamespace = null;
    this.oldValue = null;
  }
  function copyMutationRecord(original) {
    var record = new MutationRecord(original.type, original.target);
    record.addedNodes = original.addedNodes.slice();
    record.removedNodes = original.removedNodes.slice();
    record.previousSibling = original.previousSibling;
    record.nextSibling = original.nextSibling;
    record.attributeName = original.attributeName;
    record.attributeNamespace = original.attributeNamespace;
    record.oldValue = original.oldValue;
    return record;
  }
  var currentRecord, recordWithOldValue;
  function getRecord(type, target) {
    return currentRecord = new MutationRecord(type, target);
  }
  function getRecordWithOldValue(oldValue) {
    if (recordWithOldValue) return recordWithOldValue;
    recordWithOldValue = copyMutationRecord(currentRecord);
    recordWithOldValue.oldValue = oldValue;
    return recordWithOldValue;
  }
  function clearRecords() {
    currentRecord = recordWithOldValue = undefined;
  }
  function recordRepresentsCurrentMutation(record) {
    return record === recordWithOldValue || record === currentRecord;
  }
  function selectRecord(lastRecord, newRecord) {
    if (lastRecord === newRecord) return lastRecord;
    if (recordWithOldValue &amp;&amp; recordRepresentsCurrentMutation(lastRecord)) return recordWithOldValue;
    return null;
  }
  function Registration(observer, target, options) {
    this.observer = observer;
    this.target = target;
    this.options = options;
    this.transientObservedNodes = [];
  }
  Registration.prototype = {
    enqueue: function(record) {
      var records = this.observer.records_;
      var length = records.length;
      if (records.length &gt; 0) {
        var lastRecord = records[length - 1];
        var recordToReplaceLast = selectRecord(lastRecord, record);
        if (recordToReplaceLast) {
          records[length - 1] = recordToReplaceLast;
          return;
        }
      } else {
        scheduleCallback(this.observer);
      }
      records[length] = record;
    },
    addListeners: function() {
      this.addListeners_(this.target);
    },
    addListeners_: function(node) {
      var options = this.options;
      if (options.attributes) node.addEventListener(&quot;DOMAttrModified&quot;, this, true);
      if (options.characterData) node.addEventListener(&quot;DOMCharacterDataModified&quot;, this, true);
      if (options.childList) node.addEventListener(&quot;DOMNodeInserted&quot;, this, true);
      if (options.childList || options.subtree) node.addEventListener(&quot;DOMNodeRemoved&quot;, this, true);
    },
    removeListeners: function() {
      this.removeListeners_(this.target);
    },
    removeListeners_: function(node) {
      var options = this.options;
      if (options.attributes) node.removeEventListener(&quot;DOMAttrModified&quot;, this, true);
      if (options.characterData) node.removeEventListener(&quot;DOMCharacterDataModified&quot;, this, true);
      if (options.childList) node.removeEventListener(&quot;DOMNodeInserted&quot;, this, true);
      if (options.childList || options.subtree) node.removeEventListener(&quot;DOMNodeRemoved&quot;, this, true);
    },
    addTransientObserver: function(node) {
      if (node === this.target) return;
      this.addListeners_(node);
      this.transientObservedNodes.push(node);
      var registrations = registrationsTable.get(node);
      if (!registrations) registrationsTable.set(node, registrations = []);
      registrations.push(this);
    },
    removeTransientObservers: function() {
      var transientObservedNodes = this.transientObservedNodes;
      this.transientObservedNodes = [];
      transientObservedNodes.forEach(function(node) {
        this.removeListeners_(node);
        var registrations = registrationsTable.get(node);
        for (var i = 0; i &lt; registrations.length; i++) {
          if (registrations[i] === this) {
            registrations.splice(i, 1);
            break;
          }
        }
      }, this);
    },
    handleEvent: function(e) {
      e.stopImmediatePropagation();
      switch (e.type) {
       case &quot;DOMAttrModified&quot;:
        var name = e.attrName;
        var namespace = e.relatedNode.namespaceURI;
        var target = e.target;
        var record = new getRecord(&quot;attributes&quot;, target);
        record.attributeName = name;
        record.attributeNamespace = namespace;
        var oldValue = e.attrChange === MutationEvent.ADDITION ? null : e.prevValue;
        forEachAncestorAndObserverEnqueueRecord(target, function(options) {
          if (!options.attributes) return;
          if (options.attributeFilter &amp;&amp; options.attributeFilter.length &amp;&amp; options.attributeFilter.indexOf(name) === -1 &amp;&amp; options.attributeFilter.indexOf(namespace) === -1) {
            return;
          }
          if (options.attributeOldValue) return getRecordWithOldValue(oldValue);
          return record;
        });
        break;

       case &quot;DOMCharacterDataModified&quot;:
        var target = e.target;
        var record = getRecord(&quot;characterData&quot;, target);
        var oldValue = e.prevValue;
        forEachAncestorAndObserverEnqueueRecord(target, function(options) {
          if (!options.characterData) return;
          if (options.characterDataOldValue) return getRecordWithOldValue(oldValue);
          return record;
        });
        break;

       case &quot;DOMNodeRemoved&quot;:
        this.addTransientObserver(e.target);

       case &quot;DOMNodeInserted&quot;:
        var changedNode = e.target;
        var addedNodes, removedNodes;
        if (e.type === &quot;DOMNodeInserted&quot;) {
          addedNodes = [ changedNode ];
          removedNodes = [];
        } else {
          addedNodes = [];
          removedNodes = [ changedNode ];
        }
        var previousSibling = changedNode.previousSibling;
        var nextSibling = changedNode.nextSibling;
        var record = getRecord(&quot;childList&quot;, e.target.parentNode);
        record.addedNodes = addedNodes;
        record.removedNodes = removedNodes;
        record.previousSibling = previousSibling;
        record.nextSibling = nextSibling;
        forEachAncestorAndObserverEnqueueRecord(e.relatedNode, function(options) {
          if (!options.childList) return;
          return record;
        });
      }
      clearRecords();
    }
  };
  global.JsMutationObserver = JsMutationObserver;
  if (!global.MutationObserver) global.MutationObserver = JsMutationObserver;
})(window);

window.HTMLImports = window.HTMLImports || {
  flags: {}
};

(function(scope) {
  var IMPORT_LINK_TYPE = &quot;import&quot;;
  var useNative = Boolean(IMPORT_LINK_TYPE in document.createElement(&quot;link&quot;));
  var hasShadowDOMPolyfill = Boolean(window.ShadowDOMPolyfill);
  var wrap = function(node) {
    return hasShadowDOMPolyfill ? window.ShadowDOMPolyfill.wrapIfNeeded(node) : node;
  };
  var rootDocument = wrap(document);
  var currentScriptDescriptor = {
    get: function() {
      var script = window.HTMLImports.currentScript || document.currentScript || (document.readyState !== &quot;complete&quot; ? document.scripts[document.scripts.length - 1] : null);
      return wrap(script);
    },
    configurable: true
  };
  Object.defineProperty(document, &quot;_currentScript&quot;, currentScriptDescriptor);
  Object.defineProperty(rootDocument, &quot;_currentScript&quot;, currentScriptDescriptor);
  var isIE = /Trident/.test(navigator.userAgent);
  function whenReady(callback, doc) {
    doc = doc || rootDocument;
    whenDocumentReady(function() {
      watchImportsLoad(callback, doc);
    }, doc);
  }
  var requiredReadyState = isIE ? &quot;complete&quot; : &quot;interactive&quot;;
  var READY_EVENT = &quot;readystatechange&quot;;
  function isDocumentReady(doc) {
    return doc.readyState === &quot;complete&quot; || doc.readyState === requiredReadyState;
  }
  function whenDocumentReady(callback, doc) {
    if (!isDocumentReady(doc)) {
      var checkReady = function() {
        if (doc.readyState === &quot;complete&quot; || doc.readyState === requiredReadyState) {
          doc.removeEventListener(READY_EVENT, checkReady);
          whenDocumentReady(callback, doc);
        }
      };
      doc.addEventListener(READY_EVENT, checkReady);
    } else if (callback) {
      callback();
    }
  }
  function markTargetLoaded(event) {
    event.target.__loaded = true;
  }
  function watchImportsLoad(callback, doc) {
    var imports = doc.querySelectorAll(&quot;link[rel=import]&quot;);
    var parsedCount = 0, importCount = imports.length, newImports = [], errorImports = [];
    function checkDone() {
      if (parsedCount == importCount &amp;&amp; callback) {
        callback({
          allImports: imports,
          loadedImports: newImports,
          errorImports: errorImports
        });
      }
    }
    function loadedImport(e) {
      markTargetLoaded(e);
      newImports.push(this);
      parsedCount++;
      checkDone();
    }
    function errorLoadingImport(e) {
      errorImports.push(this);
      parsedCount++;
      checkDone();
    }
    if (importCount) {
      for (var i = 0, imp; i &lt; importCount &amp;&amp; (imp = imports[i]); i++) {
        if (isImportLoaded(imp)) {
          parsedCount++;
          checkDone();
        } else {
          imp.addEventListener(&quot;load&quot;, loadedImport);
          imp.addEventListener(&quot;error&quot;, errorLoadingImport);
        }
      }
    } else {
      checkDone();
    }
  }
  function isImportLoaded(link) {
    return useNative ? link.__loaded || link.import &amp;&amp; link.import.readyState !== &quot;loading&quot; : link.__importParsed;
  }
  if (useNative) {
    new MutationObserver(function(mxns) {
      for (var i = 0, l = mxns.length, m; i &lt; l &amp;&amp; (m = mxns[i]); i++) {
        if (m.addedNodes) {
          handleImports(m.addedNodes);
        }
      }
    }).observe(document.head, {
      childList: true
    });
    function handleImports(nodes) {
      for (var i = 0, l = nodes.length, n; i &lt; l &amp;&amp; (n = nodes[i]); i++) {
        if (isImport(n)) {
          handleImport(n);
        }
      }
    }
    function isImport(element) {
      return element.localName === &quot;link&quot; &amp;&amp; element.rel === &quot;import&quot;;
    }
    function handleImport(element) {
      var loaded = element.import;
      if (loaded) {
        markTargetLoaded({
          target: element
        });
      } else {
        element.addEventListener(&quot;load&quot;, markTargetLoaded);
        element.addEventListener(&quot;error&quot;, markTargetLoaded);
      }
    }
    (function() {
      if (document.readyState === &quot;loading&quot;) {
        var imports = document.querySelectorAll(&quot;link[rel=import]&quot;);
        for (var i = 0, l = imports.length, imp; i &lt; l &amp;&amp; (imp = imports[i]); i++) {
          handleImport(imp);
        }
      }
    })();
  }
  whenReady(function(detail) {
    window.HTMLImports.ready = true;
    window.HTMLImports.readyTime = new Date().getTime();
    var evt = rootDocument.createEvent(&quot;CustomEvent&quot;);
    evt.initCustomEvent(&quot;HTMLImportsLoaded&quot;, true, true, detail);
    rootDocument.dispatchEvent(evt);
  });
  scope.IMPORT_LINK_TYPE = IMPORT_LINK_TYPE;
  scope.useNative = useNative;
  scope.rootDocument = rootDocument;
  scope.whenReady = whenReady;
  scope.isIE = isIE;
})(window.HTMLImports);

(function(scope) {
  var modules = [];
  var addModule = function(module) {
    modules.push(module);
  };
  var initializeModules = function() {
    modules.forEach(function(module) {
      module(scope);
    });
  };
  scope.addModule = addModule;
  scope.initializeModules = initializeModules;
})(window.HTMLImports);

window.HTMLImports.addModule(function(scope) {
  var CSS_URL_REGEXP = /(url\()([^)]*)(\))/g;
  var CSS_IMPORT_REGEXP = /(@import[\s]+(?!url\())([^;]*)(;)/g;
  var path = {
    resolveUrlsInStyle: function(style, linkUrl) {
      var doc = style.ownerDocument;
      var resolver = doc.createElement(&quot;a&quot;);
      style.textContent = this.resolveUrlsInCssText(style.textContent, linkUrl, resolver);
      return style;
    },
    resolveUrlsInCssText: function(cssText, linkUrl, urlObj) {
      var r = this.replaceUrls(cssText, urlObj, linkUrl, CSS_URL_REGEXP);
      r = this.replaceUrls(r, urlObj, linkUrl, CSS_IMPORT_REGEXP);
      return r;
    },
    replaceUrls: function(text, urlObj, linkUrl, regexp) {
      return text.replace(regexp, function(m, pre, url, post) {
        var urlPath = url.replace(/[&quot;&#x27;]/g, &quot;&quot;);
        if (linkUrl) {
          urlPath = new URL(urlPath, linkUrl).href;
        }
        urlObj.href = urlPath;
        urlPath = urlObj.href;
        return pre + &quot;&#x27;&quot; + urlPath + &quot;&#x27;&quot; + post;
      });
    }
  };
  scope.path = path;
});

window.HTMLImports.addModule(function(scope) {
  var xhr = {
    async: true,
    ok: function(request) {
      return request.status &gt;= 200 &amp;&amp; request.status &lt; 300 || request.status === 304 || request.status === 0;
    },
    load: function(url, next, nextContext) {
      var request = new XMLHttpRequest();
      if (scope.flags.debug || scope.flags.bust) {
        url += &quot;?&quot; + Math.random();
      }
      request.open(&quot;GET&quot;, url, xhr.async);
      request.addEventListener(&quot;readystatechange&quot;, function(e) {
        if (request.readyState === 4) {
          var locationHeader = request.getResponseHeader(&quot;Location&quot;);
          var redirectedUrl = null;
          if (locationHeader) {
            var redirectedUrl = locationHeader.substr(0, 1) === &quot;/&quot; ? location.origin + locationHeader : locationHeader;
          }
          next.call(nextContext, !xhr.ok(request) &amp;&amp; request, request.response || request.responseText, redirectedUrl);
        }
      });
      request.send();
      return request;
    },
    loadDocument: function(url, next, nextContext) {
      this.load(url, next, nextContext).responseType = &quot;document&quot;;
    }
  };
  scope.xhr = xhr;
});

window.HTMLImports.addModule(function(scope) {
  var xhr = scope.xhr;
  var flags = scope.flags;
  var Loader = function(onLoad, onComplete) {
    this.cache = {};
    this.onload = onLoad;
    this.oncomplete = onComplete;
    this.inflight = 0;
    this.pending = {};
  };
  Loader.prototype = {
    addNodes: function(nodes) {
      this.inflight += nodes.length;
      for (var i = 0, l = nodes.length, n; i &lt; l &amp;&amp; (n = nodes[i]); i++) {
        this.require(n);
      }
      this.checkDone();
    },
    addNode: function(node) {
      this.inflight++;
      this.require(node);
      this.checkDone();
    },
    require: function(elt) {
      var url = elt.src || elt.href;
      elt.__nodeUrl = url;
      if (!this.dedupe(url, elt)) {
        this.fetch(url, elt);
      }
    },
    dedupe: function(url, elt) {
      if (this.pending[url]) {
        this.pending[url].push(elt);
        return true;
      }
      var resource;
      if (this.cache[url]) {
        this.onload(url, elt, this.cache[url]);
        this.tail();
        return true;
      }
      this.pending[url] = [ elt ];
      return false;
    },
    fetch: function(url, elt) {
      flags.load &amp;&amp; console.log(&quot;fetch&quot;, url, elt);
      if (!url) {
        setTimeout(function() {
          this.receive(url, elt, {
            error: &quot;href must be specified&quot;
          }, null);
        }.bind(this), 0);
      } else if (url.match(/^data:/)) {
        var pieces = url.split(&quot;,&quot;);
        var header = pieces[0];
        var body = pieces[1];
        if (header.indexOf(&quot;;base64&quot;) &gt; -1) {
          body = atob(body);
        } else {
          body = decodeURIComponent(body);
        }
        setTimeout(function() {
          this.receive(url, elt, null, body);
        }.bind(this), 0);
      } else {
        var receiveXhr = function(err, resource, redirectedUrl) {
          this.receive(url, elt, err, resource, redirectedUrl);
        }.bind(this);
        xhr.load(url, receiveXhr);
      }
    },
    receive: function(url, elt, err, resource, redirectedUrl) {
      this.cache[url] = resource;
      var $p = this.pending[url];
      for (var i = 0, l = $p.length, p; i &lt; l &amp;&amp; (p = $p[i]); i++) {
        this.onload(url, p, resource, err, redirectedUrl);
        this.tail();
      }
      this.pending[url] = null;
    },
    tail: function() {
      --this.inflight;
      this.checkDone();
    },
    checkDone: function() {
      if (!this.inflight) {
        this.oncomplete();
      }
    }
  };
  scope.Loader = Loader;
});

window.HTMLImports.addModule(function(scope) {
  var Observer = function(addCallback) {
    this.addCallback = addCallback;
    this.mo = new MutationObserver(this.handler.bind(this));
  };
  Observer.prototype = {
    handler: function(mutations) {
      for (var i = 0, l = mutations.length, m; i &lt; l &amp;&amp; (m = mutations[i]); i++) {
        if (m.type === &quot;childList&quot; &amp;&amp; m.addedNodes.length) {
          this.addedNodes(m.addedNodes);
        }
      }
    },
    addedNodes: function(nodes) {
      if (this.addCallback) {
        this.addCallback(nodes);
      }
      for (var i = 0, l = nodes.length, n, loading; i &lt; l &amp;&amp; (n = nodes[i]); i++) {
        if (n.children &amp;&amp; n.children.length) {
          this.addedNodes(n.children);
        }
      }
    },
    observe: function(root) {
      this.mo.observe(root, {
        childList: true,
        subtree: true
      });
    }
  };
  scope.Observer = Observer;
});

window.HTMLImports.addModule(function(scope) {
  var path = scope.path;
  var rootDocument = scope.rootDocument;
  var flags = scope.flags;
  var isIE = scope.isIE;
  var IMPORT_LINK_TYPE = scope.IMPORT_LINK_TYPE;
  var IMPORT_SELECTOR = &quot;link[rel=&quot; + IMPORT_LINK_TYPE + &quot;]&quot;;
  var importParser = {
    documentSelectors: IMPORT_SELECTOR,
    importsSelectors: [ IMPORT_SELECTOR, &quot;link[rel=stylesheet]:not([type])&quot;, &quot;style:not([type])&quot;, &quot;script:not([type])&quot;, &#x27;script[type=&quot;application/javascript&quot;]&#x27;, &#x27;script[type=&quot;text/javascript&quot;]&#x27; ].join(&quot;,&quot;),
    map: {
      link: &quot;parseLink&quot;,
      script: &quot;parseScript&quot;,
      style: &quot;parseStyle&quot;
    },
    dynamicElements: [],
    parseNext: function() {
      var next = this.nextToParse();
      if (next) {
        this.parse(next);
      }
    },
    parse: function(elt) {
      if (this.isParsed(elt)) {
        flags.parse &amp;&amp; console.log(&quot;[%s] is already parsed&quot;, elt.localName);
        return;
      }
      var fn = this[this.map[elt.localName]];
      if (fn) {
        this.markParsing(elt);
        fn.call(this, elt);
      }
    },
    parseDynamic: function(elt, quiet) {
      this.dynamicElements.push(elt);
      if (!quiet) {
        this.parseNext();
      }
    },
    markParsing: function(elt) {
      flags.parse &amp;&amp; console.log(&quot;parsing&quot;, elt);
      this.parsingElement = elt;
    },
    markParsingComplete: function(elt) {
      elt.__importParsed = true;
      this.markDynamicParsingComplete(elt);
      if (elt.__importElement) {
        elt.__importElement.__importParsed = true;
        this.markDynamicParsingComplete(elt.__importElement);
      }
      this.parsingElement = null;
      flags.parse &amp;&amp; console.log(&quot;completed&quot;, elt);
    },
    markDynamicParsingComplete: function(elt) {
      var i = this.dynamicElements.indexOf(elt);
      if (i &gt;= 0) {
        this.dynamicElements.splice(i, 1);
      }
    },
    parseImport: function(elt) {
      elt.import = elt.__doc;
      if (window.HTMLImports.__importsParsingHook) {
        window.HTMLImports.__importsParsingHook(elt);
      }
      if (elt.import) {
        elt.import.__importParsed = true;
      }
      this.markParsingComplete(elt);
      if (elt.__resource &amp;&amp; !elt.__error) {
        elt.dispatchEvent(new CustomEvent(&quot;load&quot;, {
          bubbles: false
        }));
      } else {
        elt.dispatchEvent(new CustomEvent(&quot;error&quot;, {
          bubbles: false
        }));
      }
      if (elt.__pending) {
        var fn;
        while (elt.__pending.length) {
          fn = elt.__pending.shift();
          if (fn) {
            fn({
              target: elt
            });
          }
        }
      }
      this.parseNext();
    },
    parseLink: function(linkElt) {
      if (nodeIsImport(linkElt)) {
        this.parseImport(linkElt);
      } else {
        linkElt.href = linkElt.href;
        this.parseGeneric(linkElt);
      }
    },
    parseStyle: function(elt) {
      var src = elt;
      elt = cloneStyle(elt);
      src.__appliedElement = elt;
      elt.__importElement = src;
      this.parseGeneric(elt);
    },
    parseGeneric: function(elt) {
      this.trackElement(elt);
      this.addElementToDocument(elt);
    },
    rootImportForElement: function(elt) {
      var n = elt;
      while (n.ownerDocument.__importLink) {
        n = n.ownerDocument.__importLink;
      }
      return n;
    },
    addElementToDocument: function(elt) {
      var port = this.rootImportForElement(elt.__importElement || elt);
      port.parentNode.insertBefore(elt, port);
    },
    trackElement: function(elt, callback) {
      var self = this;
      var done = function(e) {
        elt.removeEventListener(&quot;load&quot;, done);
        elt.removeEventListener(&quot;error&quot;, done);
        if (callback) {
          callback(e);
        }
        self.markParsingComplete(elt);
        self.parseNext();
      };
      elt.addEventListener(&quot;load&quot;, done);
      elt.addEventListener(&quot;error&quot;, done);
      if (isIE &amp;&amp; elt.localName === &quot;style&quot;) {
        var fakeLoad = false;
        if (elt.textContent.indexOf(&quot;@import&quot;) == -1) {
          fakeLoad = true;
        } else if (elt.sheet) {
          fakeLoad = true;
          var csr = elt.sheet.cssRules;
          var len = csr ? csr.length : 0;
          for (var i = 0, r; i &lt; len &amp;&amp; (r = csr[i]); i++) {
            if (r.type === CSSRule.IMPORT_RULE) {
              fakeLoad = fakeLoad &amp;&amp; Boolean(r.styleSheet);
            }
          }
        }
        if (fakeLoad) {
          setTimeout(function() {
            elt.dispatchEvent(new CustomEvent(&quot;load&quot;, {
              bubbles: false
            }));
          });
        }
      }
    },
    parseScript: function(scriptElt) {
      var script = document.createElement(&quot;script&quot;);
      script.__importElement = scriptElt;
      script.src = scriptElt.src ? scriptElt.src : generateScriptDataUrl(scriptElt);
      scope.currentScript = scriptElt;
      this.trackElement(script, function(e) {
        if (script.parentNode) {
          script.parentNode.removeChild(script);
        }
        scope.currentScript = null;
      });
      this.addElementToDocument(script);
    },
    nextToParse: function() {
      this._mayParse = [];
      return !this.parsingElement &amp;&amp; (this.nextToParseInDoc(rootDocument) || this.nextToParseDynamic());
    },
    nextToParseInDoc: function(doc, link) {
      if (doc &amp;&amp; this._mayParse.indexOf(doc) &lt; 0) {
        this._mayParse.push(doc);
        var nodes = doc.querySelectorAll(this.parseSelectorsForNode(doc));
        for (var i = 0, l = nodes.length, p = 0, n; i &lt; l &amp;&amp; (n = nodes[i]); i++) {
          if (!this.isParsed(n)) {
            if (this.hasResource(n)) {
              return nodeIsImport(n) ? this.nextToParseInDoc(n.__doc, n) : n;
            } else {
              return;
            }
          }
        }
      }
      return link;
    },
    nextToParseDynamic: function() {
      return this.dynamicElements[0];
    },
    parseSelectorsForNode: function(node) {
      var doc = node.ownerDocument || node;
      return doc === rootDocument ? this.documentSelectors : this.importsSelectors;
    },
    isParsed: function(node) {
      return node.__importParsed;
    },
    needsDynamicParsing: function(elt) {
      return this.dynamicElements.indexOf(elt) &gt;= 0;
    },
    hasResource: function(node) {
      if (nodeIsImport(node) &amp;&amp; node.__doc === undefined) {
        return false;
      }
      return true;
    }
  };
  function nodeIsImport(elt) {
    return elt.localName === &quot;link&quot; &amp;&amp; elt.rel === IMPORT_LINK_TYPE;
  }
  function generateScriptDataUrl(script) {
    var scriptContent = generateScriptContent(script);
    return &quot;data:text/javascript;charset=utf-8,&quot; + encodeURIComponent(scriptContent);
  }
  function generateScriptContent(script) {
    return script.textContent + generateSourceMapHint(script);
  }
  function generateSourceMapHint(script) {
    var owner = script.ownerDocument;
    owner.__importedScripts = owner.__importedScripts || 0;
    var moniker = script.ownerDocument.baseURI;
    var num = owner.__importedScripts ? &quot;-&quot; + owner.__importedScripts : &quot;&quot;;
    owner.__importedScripts++;
    return &quot;\n//# sourceURL=&quot; + moniker + num + &quot;.js\n&quot;;
  }
  function cloneStyle(style) {
    var clone = style.ownerDocument.createElement(&quot;style&quot;);
    clone.textContent = style.textContent;
    path.resolveUrlsInStyle(clone);
    return clone;
  }
  scope.parser = importParser;
  scope.IMPORT_SELECTOR = IMPORT_SELECTOR;
});

window.HTMLImports.addModule(function(scope) {
  var flags = scope.flags;
  var IMPORT_LINK_TYPE = scope.IMPORT_LINK_TYPE;
  var IMPORT_SELECTOR = scope.IMPORT_SELECTOR;
  var rootDocument = scope.rootDocument;
  var Loader = scope.Loader;
  var Observer = scope.Observer;
  var parser = scope.parser;
  var importer = {
    documents: {},
    documentPreloadSelectors: IMPORT_SELECTOR,
    importsPreloadSelectors: [ IMPORT_SELECTOR ].join(&quot;,&quot;),
    loadNode: function(node) {
      importLoader.addNode(node);
    },
    loadSubtree: function(parent) {
      var nodes = this.marshalNodes(parent);
      importLoader.addNodes(nodes);
    },
    marshalNodes: function(parent) {
      return parent.querySelectorAll(this.loadSelectorsForNode(parent));
    },
    loadSelectorsForNode: function(node) {
      var doc = node.ownerDocument || node;
      return doc === rootDocument ? this.documentPreloadSelectors : this.importsPreloadSelectors;
    },
    loaded: function(url, elt, resource, err, redirectedUrl) {
      flags.load &amp;&amp; console.log(&quot;loaded&quot;, url, elt);
      elt.__resource = resource;
      elt.__error = err;
      if (isImportLink(elt)) {
        var doc = this.documents[url];
        if (doc === undefined) {
          doc = err ? null : makeDocument(resource, redirectedUrl || url);
          if (doc) {
            doc.__importLink = elt;
            this.bootDocument(doc);
          }
          this.documents[url] = doc;
        }
        elt.__doc = doc;
      }
      parser.parseNext();
    },
    bootDocument: function(doc) {
      this.loadSubtree(doc);
      this.observer.observe(doc);
      parser.parseNext();
    },
    loadedAll: function() {
      parser.parseNext();
    }
  };
  var importLoader = new Loader(importer.loaded.bind(importer), importer.loadedAll.bind(importer));
  importer.observer = new Observer();
  function isImportLink(elt) {
    return isLinkRel(elt, IMPORT_LINK_TYPE);
  }
  function isLinkRel(elt, rel) {
    return elt.localName === &quot;link&quot; &amp;&amp; elt.getAttribute(&quot;rel&quot;) === rel;
  }
  function hasBaseURIAccessor(doc) {
    return !!Object.getOwnPropertyDescriptor(doc, &quot;baseURI&quot;);
  }
  function makeDocument(resource, url) {
    var doc = document.implementation.createHTMLDocument(IMPORT_LINK_TYPE);
    doc._URL = url;
    var base = doc.createElement(&quot;base&quot;);
    base.setAttribute(&quot;href&quot;, url);
    if (!doc.baseURI &amp;&amp; !hasBaseURIAccessor(doc)) {
      Object.defineProperty(doc, &quot;baseURI&quot;, {
        value: url
      });
    }
    var meta = doc.createElement(&quot;meta&quot;);
    meta.setAttribute(&quot;charset&quot;, &quot;utf-8&quot;);
    doc.head.appendChild(meta);
    doc.head.appendChild(base);
    doc.body.innerHTML = resource;
    if (window.HTMLTemplateElement &amp;&amp; HTMLTemplateElement.bootstrap) {
      HTMLTemplateElement.bootstrap(doc);
    }
    return doc;
  }
  if (!document.baseURI) {
    var baseURIDescriptor = {
      get: function() {
        var base = document.querySelector(&quot;base&quot;);
        return base ? base.href : window.location.href;
      },
      configurable: true
    };
    Object.defineProperty(document, &quot;baseURI&quot;, baseURIDescriptor);
    Object.defineProperty(rootDocument, &quot;baseURI&quot;, baseURIDescriptor);
  }
  scope.importer = importer;
  scope.importLoader = importLoader;
});

window.HTMLImports.addModule(function(scope) {
  var parser = scope.parser;
  var importer = scope.importer;
  var dynamic = {
    added: function(nodes) {
      var owner, parsed, loading;
      for (var i = 0, l = nodes.length, n; i &lt; l &amp;&amp; (n = nodes[i]); i++) {
        if (!owner) {
          owner = n.ownerDocument;
          parsed = parser.isParsed(owner);
        }
        loading = this.shouldLoadNode(n);
        if (loading) {
          importer.loadNode(n);
        }
        if (this.shouldParseNode(n) &amp;&amp; parsed) {
          parser.parseDynamic(n, loading);
        }
      }
    },
    shouldLoadNode: function(node) {
      return node.nodeType === 1 &amp;&amp; matches.call(node, importer.loadSelectorsForNode(node));
    },
    shouldParseNode: function(node) {
      return node.nodeType === 1 &amp;&amp; matches.call(node, parser.parseSelectorsForNode(node));
    }
  };
  importer.observer.addCallback = dynamic.added.bind(dynamic);
  var matches = HTMLElement.prototype.matches || HTMLElement.prototype.matchesSelector || HTMLElement.prototype.webkitMatchesSelector || HTMLElement.prototype.mozMatchesSelector || HTMLElement.prototype.msMatchesSelector;
});

(function(scope) {
  var initializeModules = scope.initializeModules;
  var isIE = scope.isIE;
  if (scope.useNative) {
    return;
  }
  if (isIE &amp;&amp; typeof window.CustomEvent !== &quot;function&quot;) {
    window.CustomEvent = function(inType, params) {
      params = params || {};
      var e = document.createEvent(&quot;CustomEvent&quot;);
      e.initCustomEvent(inType, Boolean(params.bubbles), Boolean(params.cancelable), params.detail);
      e.preventDefault = function() {
        Object.defineProperty(this, &quot;defaultPrevented&quot;, {
          get: function() {
            return true;
          }
        });
      };
      return e;
    };
    window.CustomEvent.prototype = window.Event.prototype;
  }
  initializeModules();
  var rootDocument = scope.rootDocument;
  function bootstrap() {
    window.HTMLImports.importer.bootDocument(rootDocument);
  }
  if (document.readyState === &quot;complete&quot; || document.readyState === &quot;interactive&quot; &amp;&amp; !window.attachEvent) {
    bootstrap();
  } else {
    document.addEventListener(&quot;DOMContentLoaded&quot;, bootstrap);
  }
})(window.HTMLImports);

window.CustomElements = window.CustomElements || {
  flags: {}
};

(function(scope) {
  var flags = scope.flags;
  var modules = [];
  var addModule = function(module) {
    modules.push(module);
  };
  var initializeModules = function() {
    modules.forEach(function(module) {
      module(scope);
    });
  };
  scope.addModule = addModule;
  scope.initializeModules = initializeModules;
  scope.hasNative = Boolean(document.registerElement);
  scope.isIE = /Trident/.test(navigator.userAgent);
  scope.useNative = !flags.register &amp;&amp; scope.hasNative &amp;&amp; !window.ShadowDOMPolyfill &amp;&amp; (!window.HTMLImports || window.HTMLImports.useNative);
})(window.CustomElements);

window.CustomElements.addModule(function(scope) {
  var IMPORT_LINK_TYPE = window.HTMLImports ? window.HTMLImports.IMPORT_LINK_TYPE : &quot;none&quot;;
  function forSubtree(node, cb) {
    findAllElements(node, function(e) {
      if (cb(e)) {
        return true;
      }
      forRoots(e, cb);
    });
    forRoots(node, cb);
  }
  function findAllElements(node, find, data) {
    var e = node.firstElementChild;
    if (!e) {
      e = node.firstChild;
      while (e &amp;&amp; e.nodeType !== Node.ELEMENT_NODE) {
        e = e.nextSibling;
      }
    }
    while (e) {
      if (find(e, data) !== true) {
        findAllElements(e, find, data);
      }
      e = e.nextElementSibling;
    }
    return null;
  }
  function forRoots(node, cb) {
    var root = node.shadowRoot;
    while (root) {
      forSubtree(root, cb);
      root = root.olderShadowRoot;
    }
  }
  function forDocumentTree(doc, cb) {
    _forDocumentTree(doc, cb, []);
  }
  function _forDocumentTree(doc, cb, processingDocuments) {
    doc = window.wrap(doc);
    if (processingDocuments.indexOf(doc) &gt;= 0) {
      return;
    }
    processingDocuments.push(doc);
    var imports = doc.querySelectorAll(&quot;link[rel=&quot; + IMPORT_LINK_TYPE + &quot;]&quot;);
    for (var i = 0, l = imports.length, n; i &lt; l &amp;&amp; (n = imports[i]); i++) {
      if (n.import) {
        _forDocumentTree(n.import, cb, processingDocuments);
      }
    }
    cb(doc);
  }
  scope.forDocumentTree = forDocumentTree;
  scope.forSubtree = forSubtree;
});

window.CustomElements.addModule(function(scope) {
  var flags = scope.flags;
  var forSubtree = scope.forSubtree;
  var forDocumentTree = scope.forDocumentTree;
  function addedNode(node, isAttached) {
    return added(node, isAttached) || addedSubtree(node, isAttached);
  }
  function added(node, isAttached) {
    if (scope.upgrade(node, isAttached)) {
      return true;
    }
    if (isAttached) {
      attached(node);
    }
  }
  function addedSubtree(node, isAttached) {
    forSubtree(node, function(e) {
      if (added(e, isAttached)) {
        return true;
      }
    });
  }
  var hasPolyfillMutations = !window.MutationObserver || window.MutationObserver === window.JsMutationObserver;
  scope.hasPolyfillMutations = hasPolyfillMutations;
  var isPendingMutations = false;
  var pendingMutations = [];
  function deferMutation(fn) {
    pendingMutations.push(fn);
    if (!isPendingMutations) {
      isPendingMutations = true;
      setTimeout(takeMutations);
    }
  }
  function takeMutations() {
    isPendingMutations = false;
    var $p = pendingMutations;
    for (var i = 0, l = $p.length, p; i &lt; l &amp;&amp; (p = $p[i]); i++) {
      p();
    }
    pendingMutations = [];
  }
  function attached(element) {
    if (hasPolyfillMutations) {
      deferMutation(function() {
        _attached(element);
      });
    } else {
      _attached(element);
    }
  }
  function _attached(element) {
    if (element.__upgraded__ &amp;&amp; !element.__attached) {
      element.__attached = true;
      if (element.attachedCallback) {
        element.attachedCallback();
      }
    }
  }
  function detachedNode(node) {
    detached(node);
    forSubtree(node, function(e) {
      detached(e);
    });
  }
  function detached(element) {
    if (hasPolyfillMutations) {
      deferMutation(function() {
        _detached(element);
      });
    } else {
      _detached(element);
    }
  }
  function _detached(element) {
    if (element.__upgraded__ &amp;&amp; element.__attached) {
      element.__attached = false;
      if (element.detachedCallback) {
        element.detachedCallback();
      }
    }
  }
  function inDocument(element) {
    var p = element;
    var doc = window.wrap(document);
    while (p) {
      if (p == doc) {
        return true;
      }
      p = p.parentNode || p.nodeType === Node.DOCUMENT_FRAGMENT_NODE &amp;&amp; p.host;
    }
  }
  function watchShadow(node) {
    if (node.shadowRoot &amp;&amp; !node.shadowRoot.__watched) {
      flags.dom &amp;&amp; console.log(&quot;watching shadow-root for: &quot;, node.localName);
      var root = node.shadowRoot;
      while (root) {
        observe(root);
        root = root.olderShadowRoot;
      }
    }
  }
  function handler(root, mutations) {
    if (flags.dom) {
      var mx = mutations[0];
      if (mx &amp;&amp; mx.type === &quot;childList&quot; &amp;&amp; mx.addedNodes) {
        if (mx.addedNodes) {
          var d = mx.addedNodes[0];
          while (d &amp;&amp; d !== document &amp;&amp; !d.host) {
            d = d.parentNode;
          }
          var u = d &amp;&amp; (d.URL || d._URL || d.host &amp;&amp; d.host.localName) || &quot;&quot;;
          u = u.split(&quot;/?&quot;).shift().split(&quot;/&quot;).pop();
        }
      }
      console.group(&quot;mutations (%d) [%s]&quot;, mutations.length, u || &quot;&quot;);
    }
    var isAttached = inDocument(root);
    mutations.forEach(function(mx) {
      if (mx.type === &quot;childList&quot;) {
        forEach(mx.addedNodes, function(n) {
          if (!n.localName) {
            return;
          }
          addedNode(n, isAttached);
        });
        forEach(mx.removedNodes, function(n) {
          if (!n.localName) {
            return;
          }
          detachedNode(n);
        });
      }
    });
    flags.dom &amp;&amp; console.groupEnd();
  }
  function takeRecords(node) {
    node = window.wrap(node);
    if (!node) {
      node = window.wrap(document);
    }
    while (node.parentNode) {
      node = node.parentNode;
    }
    var observer = node.__observer;
    if (observer) {
      handler(node, observer.takeRecords());
      takeMutations();
    }
  }
  var forEach = Array.prototype.forEach.call.bind(Array.prototype.forEach);
  function observe(inRoot) {
    if (inRoot.__observer) {
      return;
    }
    var observer = new MutationObserver(handler.bind(this, inRoot));
    observer.observe(inRoot, {
      childList: true,
      subtree: true
    });
    inRoot.__observer = observer;
  }
  function upgradeDocument(doc) {
    doc = window.wrap(doc);
    flags.dom &amp;&amp; console.group(&quot;upgradeDocument: &quot;, doc.baseURI.split(&quot;/&quot;).pop());
    var isMainDocument = doc === window.wrap(document);
    addedNode(doc, isMainDocument);
    observe(doc);
    flags.dom &amp;&amp; console.groupEnd();
  }
  function upgradeDocumentTree(doc) {
    forDocumentTree(doc, upgradeDocument);
  }
  var originalCreateShadowRoot = Element.prototype.createShadowRoot;
  if (originalCreateShadowRoot) {
    Element.prototype.createShadowRoot = function() {
      var root = originalCreateShadowRoot.call(this);
      window.CustomElements.watchShadow(this);
      return root;
    };
  }
  scope.watchShadow = watchShadow;
  scope.upgradeDocumentTree = upgradeDocumentTree;
  scope.upgradeDocument = upgradeDocument;
  scope.upgradeSubtree = addedSubtree;
  scope.upgradeAll = addedNode;
  scope.attached = attached;
  scope.takeRecords = takeRecords;
});

window.CustomElements.addModule(function(scope) {
  var flags = scope.flags;
  function upgrade(node, isAttached) {
    if (!node.__upgraded__ &amp;&amp; node.nodeType === Node.ELEMENT_NODE) {
      var is = node.getAttribute(&quot;is&quot;);
      var definition = scope.getRegisteredDefinition(node.localName) || scope.getRegisteredDefinition(is);
      if (definition) {
        if (is &amp;&amp; definition.tag == node.localName || !is &amp;&amp; !definition.extends) {
          return upgradeWithDefinition(node, definition, isAttached);
        }
      }
    }
  }
  function upgradeWithDefinition(element, definition, isAttached) {
    flags.upgrade &amp;&amp; console.group(&quot;upgrade:&quot;, element.localName);
    if (definition.is) {
      element.setAttribute(&quot;is&quot;, definition.is);
    }
    implementPrototype(element, definition);
    element.__upgraded__ = true;
    created(element);
    if (isAttached) {
      scope.attached(element);
    }
    scope.upgradeSubtree(element, isAttached);
    flags.upgrade &amp;&amp; console.groupEnd();
    return element;
  }
  function implementPrototype(element, definition) {
    if (Object.__proto__) {
      element.__proto__ = definition.prototype;
    } else {
      customMixin(element, definition.prototype, definition.native);
      element.__proto__ = definition.prototype;
    }
  }
  function customMixin(inTarget, inSrc, inNative) {
    var used = {};
    var p = inSrc;
    while (p !== inNative &amp;&amp; p !== HTMLElement.prototype) {
      var keys = Object.getOwnPropertyNames(p);
      for (var i = 0, k; k = keys[i]; i++) {
        if (!used[k]) {
          Object.defineProperty(inTarget, k, Object.getOwnPropertyDescriptor(p, k));
          used[k] = 1;
        }
      }
      p = Object.getPrototypeOf(p);
    }
  }
  function created(element) {
    if (element.createdCallback) {
      element.createdCallback();
    }
  }
  scope.upgrade = upgrade;
  scope.upgradeWithDefinition = upgradeWithDefinition;
  scope.implementPrototype = implementPrototype;
});

window.CustomElements.addModule(function(scope) {
  var isIE = scope.isIE;
  var upgradeDocumentTree = scope.upgradeDocumentTree;
  var upgradeAll = scope.upgradeAll;
  var upgradeWithDefinition = scope.upgradeWithDefinition;
  var implementPrototype = scope.implementPrototype;
  var useNative = scope.useNative;
  function register(name, options) {
    var definition = options || {};
    if (!name) {
      throw new Error(&quot;document.registerElement: first argument &#x60;name&#x60; must not be empty&quot;);
    }
    if (name.indexOf(&quot;-&quot;) &lt; 0) {
      throw new Error(&quot;document.registerElement: first argument (&#x27;name&#x27;) must contain a dash (&#x27;-&#x27;). Argument provided was &#x27;&quot; + String(name) + &quot;&#x27;.&quot;);
    }
    if (isReservedTag(name)) {
      throw new Error(&quot;Failed to execute &#x27;registerElement&#x27; on &#x27;Document&#x27;: Registration failed for type &#x27;&quot; + String(name) + &quot;&#x27;. The type name is invalid.&quot;);
    }
    if (getRegisteredDefinition(name)) {
      throw new Error(&quot;DuplicateDefinitionError: a type with name &#x27;&quot; + String(name) + &quot;&#x27; is already registered&quot;);
    }
    if (!definition.prototype) {
      definition.prototype = Object.create(HTMLElement.prototype);
    }
    definition.__name = name.toLowerCase();
    definition.lifecycle = definition.lifecycle || {};
    definition.ancestry = ancestry(definition.extends);
    resolveTagName(definition);
    resolvePrototypeChain(definition);
    overrideAttributeApi(definition.prototype);
    registerDefinition(definition.__name, definition);
    definition.ctor = generateConstructor(definition);
    definition.ctor.prototype = definition.prototype;
    definition.prototype.constructor = definition.ctor;
    if (scope.ready) {
      upgradeDocumentTree(document);
    }
    return definition.ctor;
  }
  function overrideAttributeApi(prototype) {
    if (prototype.setAttribute._polyfilled) {
      return;
    }
    var setAttribute = prototype.setAttribute;
    prototype.setAttribute = function(name, value) {
      changeAttribute.call(this, name, value, setAttribute);
    };
    var removeAttribute = prototype.removeAttribute;
    prototype.removeAttribute = function(name) {
      changeAttribute.call(this, name, null, removeAttribute);
    };
    prototype.setAttribute._polyfilled = true;
  }
  function changeAttribute(name, value, operation) {
    name = name.toLowerCase();
    var oldValue = this.getAttribute(name);
    operation.apply(this, arguments);
    var newValue = this.getAttribute(name);
    if (this.attributeChangedCallback &amp;&amp; newValue !== oldValue) {
      this.attributeChangedCallback(name, oldValue, newValue);
    }
  }
  function isReservedTag(name) {
    for (var i = 0; i &lt; reservedTagList.length; i++) {
      if (name === reservedTagList[i]) {
        return true;
      }
    }
  }
  var reservedTagList = [ &quot;annotation-xml&quot;, &quot;color-profile&quot;, &quot;font-face&quot;, &quot;font-face-src&quot;, &quot;font-face-uri&quot;, &quot;font-face-format&quot;, &quot;font-face-name&quot;, &quot;missing-glyph&quot; ];
  function ancestry(extnds) {
    var extendee = getRegisteredDefinition(extnds);
    if (extendee) {
      return ancestry(extendee.extends).concat([ extendee ]);
    }
    return [];
  }
  function resolveTagName(definition) {
    var baseTag = definition.extends;
    for (var i = 0, a; a = definition.ancestry[i]; i++) {
      baseTag = a.is &amp;&amp; a.tag;
    }
    definition.tag = baseTag || definition.__name;
    if (baseTag) {
      definition.is = definition.__name;
    }
  }
  function resolvePrototypeChain(definition) {
    if (!Object.__proto__) {
      var nativePrototype = HTMLElement.prototype;
      if (definition.is) {
        var inst = document.createElement(definition.tag);
        nativePrototype = Object.getPrototypeOf(inst);
      }
      var proto = definition.prototype, ancestor;
      var foundPrototype = false;
      while (proto) {
        if (proto == nativePrototype) {
          foundPrototype = true;
        }
        ancestor = Object.getPrototypeOf(proto);
        if (ancestor) {
          proto.__proto__ = ancestor;
        }
        proto = ancestor;
      }
      if (!foundPrototype) {
        console.warn(definition.tag + &quot; prototype not found in prototype chain for &quot; + definition.is);
      }
      definition.native = nativePrototype;
    }
  }
  function instantiate(definition) {
    return upgradeWithDefinition(domCreateElement(definition.tag), definition);
  }
  var registry = {};
  function getRegisteredDefinition(name) {
    if (name) {
      return registry[name.toLowerCase()];
    }
  }
  function registerDefinition(name, definition) {
    registry[name] = definition;
  }
  function generateConstructor(definition) {
    return function() {
      return instantiate(definition);
    };
  }
  var HTML_NAMESPACE = &quot;http://www.w3.org/1999/xhtml&quot;;
  function createElementNS(namespace, tag, typeExtension) {
    if (namespace === HTML_NAMESPACE) {
      return createElement(tag, typeExtension);
    } else {
      return domCreateElementNS(namespace, tag);
    }
  }
  function createElement(tag, typeExtension) {
    if (tag) {
      tag = tag.toLowerCase();
    }
    if (typeExtension) {
      typeExtension = typeExtension.toLowerCase();
    }
    var definition = getRegisteredDefinition(typeExtension || tag);
    if (definition) {
      if (tag == definition.tag &amp;&amp; typeExtension == definition.is) {
        return new definition.ctor();
      }
      if (!typeExtension &amp;&amp; !definition.is) {
        return new definition.ctor();
      }
    }
    var element;
    if (typeExtension) {
      element = createElement(tag);
      element.setAttribute(&quot;is&quot;, typeExtension);
      return element;
    }
    element = domCreateElement(tag);
    if (tag.indexOf(&quot;-&quot;) &gt;= 0) {
      implementPrototype(element, HTMLElement);
    }
    return element;
  }
  var domCreateElement = document.createElement.bind(document);
  var domCreateElementNS = document.createElementNS.bind(document);
  var isInstance;
  if (!Object.__proto__ &amp;&amp; !useNative) {
    isInstance = function(obj, ctor) {
      if (obj instanceof ctor) {
        return true;
      }
      var p = obj;
      while (p) {
        if (p === ctor.prototype) {
          return true;
        }
        p = p.__proto__;
      }
      return false;
    };
  } else {
    isInstance = function(obj, base) {
      return obj instanceof base;
    };
  }
  function wrapDomMethodToForceUpgrade(obj, methodName) {
    var orig = obj[methodName];
    obj[methodName] = function() {
      var n = orig.apply(this, arguments);
      upgradeAll(n);
      return n;
    };
  }
  wrapDomMethodToForceUpgrade(Node.prototype, &quot;cloneNode&quot;);
  wrapDomMethodToForceUpgrade(document, &quot;importNode&quot;);
  if (isIE) {
    (function() {
      var importNode = document.importNode;
      document.importNode = function() {
        var n = importNode.apply(document, arguments);
        if (n.nodeType == n.DOCUMENT_FRAGMENT_NODE) {
          var f = document.createDocumentFragment();
          f.appendChild(n);
          return f;
        } else {
          return n;
        }
      };
    })();
  }
  document.registerElement = register;
  document.createElement = createElement;
  document.createElementNS = createElementNS;
  scope.registry = registry;
  scope.instanceof = isInstance;
  scope.reservedTagList = reservedTagList;
  scope.getRegisteredDefinition = getRegisteredDefinition;
  document.register = document.registerElement;
});

(function(scope) {
  var useNative = scope.useNative;
  var initializeModules = scope.initializeModules;
  var isIE = scope.isIE;
  if (useNative) {
    var nop = function() {};
    scope.watchShadow = nop;
    scope.upgrade = nop;
    scope.upgradeAll = nop;
    scope.upgradeDocumentTree = nop;
    scope.upgradeSubtree = nop;
    scope.takeRecords = nop;
    scope.instanceof = function(obj, base) {
      return obj instanceof base;
    };
  } else {
    initializeModules();
  }
  var upgradeDocumentTree = scope.upgradeDocumentTree;
  var upgradeDocument = scope.upgradeDocument;
  if (!window.wrap) {
    if (window.ShadowDOMPolyfill) {
      window.wrap = window.ShadowDOMPolyfill.wrapIfNeeded;
      window.unwrap = window.ShadowDOMPolyfill.unwrapIfNeeded;
    } else {
      window.wrap = window.unwrap = function(node) {
        return node;
      };
    }
  }
  if (window.HTMLImports) {
    window.HTMLImports.__importsParsingHook = function(elt) {
      if (elt.import) {
        upgradeDocument(wrap(elt.import));
      }
    };
  }
  function bootstrap() {
    upgradeDocumentTree(window.wrap(document));
    window.CustomElements.ready = true;
    var requestAnimationFrame = window.requestAnimationFrame || function(f) {
      setTimeout(f, 16);
    };
    requestAnimationFrame(function() {
      setTimeout(function() {
        window.CustomElements.readyTime = Date.now();
        if (window.HTMLImports) {
          window.CustomElements.elapsed = window.CustomElements.readyTime - window.HTMLImports.readyTime;
        }
        document.dispatchEvent(new CustomEvent(&quot;WebComponentsReady&quot;, {
          bubbles: true
        }));
      });
    });
  }
  if (isIE &amp;&amp; typeof window.CustomEvent !== &quot;function&quot;) {
    window.CustomEvent = function(inType, params) {
      params = params || {};
      var e = document.createEvent(&quot;CustomEvent&quot;);
      e.initCustomEvent(inType, Boolean(params.bubbles), Boolean(params.cancelable), params.detail);
      e.preventDefault = function() {
        Object.defineProperty(this, &quot;defaultPrevented&quot;, {
          get: function() {
            return true;
          }
        });
      };
      return e;
    };
    window.CustomEvent.prototype = window.Event.prototype;
  }
  if (document.readyState === &quot;complete&quot; || scope.flags.eager) {
    bootstrap();
  } else if (document.readyState === &quot;interactive&quot; &amp;&amp; !window.attachEvent &amp;&amp; (!window.HTMLImports || window.HTMLImports.ready)) {
    bootstrap();
  } else {
    var loadEvent = window.HTMLImports &amp;&amp; !window.HTMLImports.ready ? &quot;HTMLImportsLoaded&quot; : &quot;DOMContentLoaded&quot;;
    window.addEventListener(loadEvent, bootstrap);
  }
})(window.CustomElements);

if (typeof HTMLTemplateElement === &quot;undefined&quot;) {
  (function() {
    var TEMPLATE_TAG = &quot;template&quot;;
    var contentDoc = document.implementation.createHTMLDocument(&quot;template&quot;);
    var canDecorate = true;
    HTMLTemplateElement = function() {};
    HTMLTemplateElement.prototype = Object.create(HTMLElement.prototype);
    HTMLTemplateElement.decorate = function(template) {
      if (!template.content) {
        template.content = contentDoc.createDocumentFragment();
      }
      var child;
      while (child = template.firstChild) {
        template.content.appendChild(child);
      }
      if (canDecorate) {
        try {
          Object.defineProperty(template, &quot;innerHTML&quot;, {
            get: function() {
              var o = &quot;&quot;;
              for (var e = this.content.firstChild; e; e = e.nextSibling) {
                o += e.outerHTML || escapeData(e.data);
              }
              return o;
            },
            set: function(text) {
              contentDoc.body.innerHTML = text;
              HTMLTemplateElement.bootstrap(contentDoc);
              while (this.content.firstChild) {
                this.content.removeChild(this.content.firstChild);
              }
              while (contentDoc.body.firstChild) {
                this.content.appendChild(contentDoc.body.firstChild);
              }
            },
            configurable: true
          });
        } catch (err) {
          canDecorate = false;
        }
      }
    };
    HTMLTemplateElement.bootstrap = function(doc) {
      var templates = doc.querySelectorAll(TEMPLATE_TAG);
      for (var i = 0, l = templates.length, t; i &lt; l &amp;&amp; (t = templates[i]); i++) {
        HTMLTemplateElement.decorate(t);
      }
    };
    window.addEventListener(&quot;DOMContentLoaded&quot;, function() {
      HTMLTemplateElement.bootstrap(document);
    });
    var createElement = document.createElement;
    document.createElement = function() {
      &quot;use strict&quot;;
      var el = createElement.apply(document, arguments);
      if (el.localName == &quot;template&quot;) {
        HTMLTemplateElement.decorate(el);
      }
      return el;
    };
    var escapeDataRegExp = /[&amp;\u00A0&lt;&gt;]/g;
    function escapeReplace(c) {
      switch (c) {
       case &quot;&amp;&quot;:
        return &quot;&amp;amp;&quot;;

       case &quot;&lt;&quot;:
        return &quot;&amp;lt;&quot;;

       case &quot;&gt;&quot;:
        return &quot;&amp;gt;&quot;;

       case &quot; &quot;:
        return &quot;&amp;nbsp;&quot;;
      }
    }
    function escapeData(s) {
      return s.replace(escapeDataRegExp, escapeReplace);
    }
  })();
}

(function(scope) {
  var style = document.createElement(&quot;style&quot;);
  style.textContent = &quot;&quot; + &quot;body {&quot; + &quot;transition: opacity ease-in 0.2s;&quot; + &quot; } \n&quot; + &quot;body[unresolved] {&quot; + &quot;opacity: 0; display: block; overflow: hidden; position: relative;&quot; + &quot; } \n&quot;;
  var head = document.querySelector(&quot;head&quot;);
  head.insertBefore(style, head.firstChild);
})(window.WebComponents);
    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
